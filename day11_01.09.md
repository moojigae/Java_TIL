## 상속
- 부모 클래스가 가지고 있는 멤버(필드, 메소드)들을 자식 클래스에서 직접 만들지 않고 상속을 받음으로서 새 클래스가 자신의 멤버처럼 사용할 수 있는 기능
> 상속의 목적
- 클래스의 `재사용`, 연관된 일련의 클래스들에 대한 공통적인 규약 정의

> 상속의 장점
- 적은 양의 코드로 새로운 클래스 작성 가능
- 코드를 부모가 공통적으로 관리하기 때문에 코드의 추가 및 변경 용이
- 코드의 중복을 제거하여 프로그램의 생산성/유지보수에 크게 기여

### 상속의 특징
1. 모든 클래스는 Object클래스의 후손
- Object클래스가 제공하는 메소드를 오버라이딩하여 메소드 재구현 가능
2. 부모클래스의 생성자, 초기화 블록은 상속 안됨
- 자식 클래스 생성 시, 부모 클래스 생성자가 먼저 실행
- 자식 클래스 생성자 안에 부모 클래스 생성자를 호출하고 싶으면 super()활용
3. 부모의 private멤버는 상속은 되지만 직접 접근 불가
- 자식 객체 생성 시에 부모의 필드 값과 전달 받은 경우, 자식 생성자 안에서 부모의 private 필드에 직접 접근하여 대입 불가
- super()을 이용하여 전달받은 부모 필드 값을 부모 생성자 쪽으로 넘겨 생성하거나 setter, getter메소드를 이용하여 접근

### 상속 방법
- 클래스 간의 상속 시에는 extends 키워드 사용
```
[접근제한자] class 클래스명(자식) extends 클래스명(부모) {}
ex. public class Academy extends Company {}
```

### 단일 상속과 다중 상속
- 클래스간의 관계가 다중 상속보다 명확하고 신뢰성 있는 코드 작성을 하는 자바에서는 다중 상속 미지원(가능은 하나 사용 안함)-> 단일상속만 지원
- 다중상속을 원하는 경우 부모에 부모로 올라가는 계단방식으로 해결을 함 

### super()와 super.
> super() 
- 부모 생성자를 호출하는 메소드
- 기본적으로 후손 생성자에게 부모 생성자가 포함되어 있음 
- 후손 객체 생성 시에는 부모부터 생성이 되기 때문에 후손 클래스 생성자 안에는 부모 생성자를 호출하는 super()가 첫줄에 존재해야 함

> super.
- 부모의 주소값을 가지고 있어서 부모클래스 객체에 접근하여 필드나 메소드 호출 시 사용 / this와 비슷한 동작 개념
- this : 나한테 있는 생성자를 불러옴

### 오버라이딩
- 부모에게 상속받은 메소드를 자식 클래스에게 맞게 재정의/ 메소드 재작성
- 기본적으로 상속이 있어야 오버라이딩이 가능하고 상속이 없으면 오버라이딩 존재하지 않음
- 모든 클래스에서 다 오버라이딩 가능(모든 클래스의 최상위 부모는 Object이기 때문)

> 특징
- 메소드 헤드라인 위에 반드시 Annotation, @Override 표시
- 접근 제어자를 부모 것보다 같거나 넓은 범위로 변경 가능
- 부모 메소드의 예외처리 클래스 처리범위보다 좁은 범위로 예외처리 클래스 수정 가능

> 성립조건
- 메소드 이름 동일
- 매개변수의 개수와 타입 동일
- 리턴 타입 동일
- private 메소드 오버라이딩 불가
- final 메소드 오버라이딩 불가

### final 예약어
- final 붙으면 종단의 의미로 수정을 끝낸다
> final 메소드 : 상속 시 오버라이딩이 불가능한 메소드 : 종단의 의미로 수정이 끝나기 때문에 수정할 수 있는 `오버라이딩 불가능`
> final이 클래스에 붙으면 `상속이 불가능`해짐 
> final이 필드나 지역변수에 붙으면 값 수정 불가능

### 유의 사항
> abstrack = 미완성된 메소드 {} 몸통 부분이 없기 때문에 상속을 받아서 강제로 완성 시킴
- 클래스에 abstrack(상속 받아야만 완성 됨)과 final(상속불가)을 동시에 사용 불가능
- 메소드 static과 abstrack
	- 미완성 된 것을 공유(static)와 사용 할 수 없다
- abstrack 메소드의 접근제어자로 private 불가능

### to String 그 객체의 대표값 반환
- 그 클래스 객체에 대한 대표값인 주소값을 반환하게 되어 있음