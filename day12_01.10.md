### 오버라이딩
- 부모 클래스의 메소드와 자식 클래스 메소드 이름 동일
- 매개변수 개수, 타입 동일
- 리턴타입 동일
- 접근제한자가 같거나 더 넓어야 함

## 다형성
- 부모 클래스 하나로 여러 자식 객체들을 다룰 수 있음
- 상속을 이용해 부모 타입(자료형/클래스)으로부터 파생된 여러가지 타입의 자식 객체(부모에게 상속받은 여러개의 자식 객체)를 부모 클래스 타입 하나로 다룰 수 있는 기술 
- 모든 클래스는 Object의 자식이기 때문에 어떻게 적용하는가는 달라도 적용은 다 됨
ex. Parent p = new Parent();   new Parent()객체를 Parent 타입이 받아줌
    Parent p = new Child2();

### 클래스 형변환
> 업 캐스팅 
- 부모 타입의 참조형 변수가 모든 자식 객체를 받을 수 있는 것
- 자식 객체의 주소를 전달받은 부모타입의 참조변수를 통해서 사용할 수 있는 후송의 정보는 `원래 부모타입이었던 멤버만 참조 가능`
```
// Sonata 클래스는 Car 클래스의 후손
Car c = new Sonata();  
// Sonata 클래스형에서 Car클래스형으로 바뀜
```

> 다운 캐스팅
- 자식이 부모로 바뀌는 것 
- 자동으로 처리되지 않기 때문에 반드시 후손 타입을 명시해서 형변환
- 클래스 간의 형변환은 `반드시 상속 관계에 있는 클래스끼리`만 가능
```
//Sonata 클래스는 Car 클래스의 후손
Car c = new Sonata();
((Sonata)c).moveSonata();
```

### instanceof 연산자
- 참조형 변수가 `어떤 클래스 형의 객체 주소를 참조하고 있는지 확인` 할 때 사용하는 연산자로 클래스 타입이 맞으면 true 맞지 않으면 false 반환
```
- 표현식
if(레퍼런스 instanceof 클래스타입){ 
	true일 때 처리할 내용, 해당 클래스 타입으로 down casting
}

ex. if(c instanceof Sonata){
    ((Sonata)c).moveSonata();
} else if(c instanceof Avante){
    ((Avante)c).moveAvante();
} else if(c instanceof Grandure){
    ((Grandure)c).moveGrandure();
}
```

### 바인딩
- 실제 실행할 메소드 코드와 호출하는 코드를 연결 시키는 것
- 처음 컴파일 될 때는 타입을 보고 실행되는 정적 바인딩으로 실행
- 동적바인딩 
    - 컴파일 시 정적바인딩 된 메소드를 실행할 당시의 객체 타입을 기준으로 바인딩 되는 것
	- 오버라이딩되면 타입을 따라가지 않고 실행할 당시의 객체 타입을 기준으로 바인딩되어 우선적으로 수행
- 정적바인딩 
	- 기존의 방식대로 타입을 보고 실행하는 것 

### 추상 클래스(abstract class)
- 추상 메소드가 있는 것
- 몸체 없는 메소드를 포함한 클래스
- 추상 클래스일 경우 클래스 선언부에 abstract 키워드 사용
> [접근제한자]abstract class 클래스명 {}

### 추상 메소드(abstract method)
- 몸체 없는 메소드
- 추상 메소드의 선언부에 abstract 키워드 사용
- 상속 시 반드시 구현해야 하는, 오버라이딩이 강제화 되는 메소드
- 강제 규약과 일반 메소드, 변수를 같이 넘기고 싶을 때 사용
> [접근제한자]abstract 반환형 메소드명(자료형 변수명);

#### 특징
- 미완성 클래스(abstract 키워드 사용) 자체적으로 객체 생성 불가(미완성이기 때문에 메모리에 올려서 사용 안됨) -> 반드시 상속하여 객체 생성
- abstract 메소드가 포함된 클래스는 반드시 abstract 클래스 
- abstract 메소드가 없어도 abstract 클래스 선언 가능
- 클래스 내에 일반 변수, 메소드 포함 가능
- 공통 규약을 만들고 싶을 때 사용함
- 추상 메소드가 없어도 공통 규약이 있으면 사용 가능
- 객체 생성은 안되지만 참조형 변수 타입으로는 사용 가능

#### 장점
- 일관된 인터페이스 제공(공통 규약)
- 꼭 필요한 기능 강제화

### 인터페이스
- 공통 규약 정의
- 추상클래스보다 더 강제화가 심함
- 메소드 통일성을 부여하기 위해 `추상 메소드만 따로 모아 놓음`
- 강제규약만 넘기고 일반 변수나 메소드는 같이 넘기고 싶지 않을 때 사용
```
[접근제한자] interface 인터페이스명 {
    // 상수도 멤버로 포함할 수 있음
    public static final 자료형 변수명 = 초기값;

    // 추상 메소드만 선언 가능
    [public abstract] 반환자료형 메소드명([자료형 매개변수]);
    //public abstract가 생략되기 때문에 오버라이딩 시 반드시 public 표기해야 함
}
```

#### 특징
- 추상 메소드만 들어가기 때문에 선언부 중에 public abstract 생략 가능
- 모든 인터페이스의 메소드는 묵시적으로 public이고 abstract임
- 변수는 묵시적으로 public static final이기 때문에 인터페이스 변수의 값 변경 시도 시 컴파일 시 에러 발생
- 객체 생성은 안되나 참조형 변수로는 가능
- 다중 상속이 가능함 
	- 변수가 static으로 선언되기 때문에 가능