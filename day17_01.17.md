## 컬렉션(Collection)
- 메모리상에서 자료를 구조적으로 처리하는 방법을 자료구조라 일컫는데 컬렉션은 자바에서 제공하는 자료구조를 담당하는 프레임워크
- `추가, 삭제, 정렬 등의 기능처리가 간단하게 해결되어 자료구조적 알고리즘을 구현할 필요 없음`
- java.util 패키지에 포함되며, 인터페이스를 통해 정형화된 방법으로 다양한 컬렉션 클래스 이용 가능

### 배열의 문제점
1. 한 번 크기를 지정하면 변경할 수 없음
- 필요에 따라 공간을 늘리거나 줄일 수 없음. 공간 크기가 부족하면 에러가 발생 -> 할당 시 넉넉한 크기로 할당하게 됨(메모리 낭비)
2. 기록된 데이터에 대한 중간 위치의 추가, 삭제가 불편
3. 한 타입의 데이터만 저장 가능

### 컬렉션의 장점
1. 저장하는 크기의 제약이 없음
2. 추가, 삭제, 정렬 등의 기능 처리가 간단하게 해결
3. 여러 타입의 데이터가 저장 가능(잘 사용되지 않음)
- 안에 어떤 타입이 들어있는지 모르기 때문에 데이터를 꺼낼 때 마다 타입을 확인해야해서 불편하기 때문에 제네릭을 이용해 한 타입만 들어가게 사용
- 객체만 저장할 수 있기 때문에 필요에 따라 기본 자료형을 저장해야 하는 경우 Wrapper클래스 사용
- 제네릭을 지정하지 않으면 기본으로 받는 타입이 Object이고 Object는 모든 클래스의 최상위 부모이기 때문에 다형성에 의해 모든 타입의 자식을 받을 수 있기 때문에 여러 타입의 데이터가 저장이 가능

### 컬렉션의 주요 인터페이스
- 컬렉션 인터페이스를 List와 Set만 상속받고 Map은 상속받지 않음
- 컬렉션 인터페이스를 상속 받았기 때문에 List와 Set은 메소드 비슷하고 Map은 다름

```
List 계열 - 순서를 유지하고 저장 / 중복 저장 가능
Set 계열 - 순서를 유지하지 않고 저장 / 중복 저장 안됨
Map 계열 - 순서를 유지하지 않고 저장 / 키와 값의 쌍으로 저장 / 키는 중복 저장 안됨 / 키는 set방식이라고 불려짐
```

### List 
- 콜렉션 안이 배열로 구현되어 있음
- 자료들을 순차적으로 나열한 자료구조로 `인덱스로 관리`되며, 중복해서 객체 저장 가능

> ArrayList
- List의 후손으로 초기 저장용량은 10으로 자동 설정 
- 크기가 증가되면 자동적으로 크기가 증가되고 고정도 가능 
- 동기화를 제공하지 않음

> Vector 
- ArrayList와 동등하지만 동기화를 제공한다는 점이 다르고 동기화는 효율성이 떨어짐 -> List 객체들 중에서 가장 성능이 좋지 않음

> LinkedList 
- 특정 인덱스에서 객체를 제거하거나 추가하게 되면 바로 앞/뒤 링크만 변경하면 되기 때문에 객체 삭제와 삽입이 빈번하게 일어나는 곳에 ArrayList보다 성능이 좋음

> Comparable 인터페이스
- java.lang 패키지 밑에 있기 때문에 import 필요 없음
- compareTo() 사용
- 한 개의 정렬 기준을 가짐

> Comparator 인터페이스
- java.util 패키지
- compare() 메소드 사용 
- 여러 개의 정렬 기준 가질 수 있음

> Collections.sort()
- comparable을 상속받아 comparaTo 메소드 재정의를 통해 정렬 구현(한 개의 정렬)
- 지정한 Comparator 클래스에 의한 정렬(여러 개의 정렬) 두 가지로 가능하다 

