## 객체
### 배열의 단점
1. 같은 자료형만 담을 수 있음
2. 크기가 달라지면 새로 만들어서 넣어야 함

### 객체지향언어
- 현실 세계의 모든 것은 객체로 불러짐
- 현실 세계의 모든 상호작용을 컴퓨터로 옮겨 놓은 것을 객체지향언어
```
객체 지향 4대 특징
1. 캡슐화
2. 상속
3. 다형성
4. 추상화
```

### 자바에서의 객체
- `클래스에 정의`된 내용대로 new 연산자와 생성자를 통해 메모리영역(heap)에 생성된 것
	- 클래스에 정의된 내용이 아닌 것은 객체가 아님 ex. int[][] iArr1 = {{1,2,3,4,6},{6,7,8,9,10}}; 은 객체가 아님
- 클래스에 정의된 내용대로 메모리(Heap영역)에 할당된 결과물(Object)
- 인스턴스화(instantiation) : 클래스를 객체로 만드는 것
- 객체의 할당 : new 연산자와 생성자를 사용하여 객체 생성 시 heap 메모리 공간에 서로 다른 자료형의 데이터가 연속으로 나열/ 할당된 객체 공간
- 자료형의 크기만큼 할당이 되기 때문에 객체에서의 할당되는 크기는 일정하지 않고 다를 수 있음
- 객체 instance라고도 부름

### 클래스의 등장 배경
- 변수 : 1개의 자료형, 1개의 데이터
- 배열 : 1개의 자료형, 여러 개의 데이터
- 구조체 : 여러 개의 자료형, 여러 개의 데이터 / 구조체가 나오면서 클래스가 생김
	- 구조체는 밖에서 쉽게 접근하여 데이터를 보거나 변경이 가능했는데 이를 방지하기 위해 캡슐화가 생김

> 클래스 : 구조체가 배경이되어서 여러 개의 자료형, 데이터 가능해짐
	- 추상화를 통해 클래스가 만들어짐
	- 구조체에 외부에서의 접근을 막기 위해 캡슐화하였는데 데이터 보관의 의미는 커졌지만 외부에서 데이터 가공이 어려워서 이를 가공을 위해 연산처리 할 수 있는 기능을 넣어 놓은 것을 클래스라고 부름
	- 사물이나 개념의 공통 요소를 `추상화`하여 정의하기 때문에 사물에 대한 공통적인 것만 들어감
	- 클래스는 객체를 만들기 위한 설계도나 틀이라고 부름

#### 추상화
- 유연성을 확보하기 위해 구체적인 것은 제거한다는 의미
- 프로그램에서 필요한 공통점을 추출하고, 불필요한 공통점을 제거하는 과정
- 앞 페이지에서 정리된 변수명과 자료형을 클래스 다이어그램으로 표현
```
     person             클래스명
- pNo : String		    - : 데이터 접근제한자
- name : String		    전체가 클래스 안에 들어감
- gender : char		    person안에 내용이 기능나타 냄
- address : String
- phone : String
- age : int
```

### 캡슐화 원칙
- 클래스의 멤버 변수에 대한 접근 권한은 `private을 원칙`으로 한다
- 캡슐화 할 때는 private을 사용
- 연산처리를 목적으로 하는 함수들을 클래스 내부에 작성
- 멤버 함수(메소드)는 클래스 밖에서 접근할 수 있도록 public으로 설정

### 클래스 선언
```
[접근제한자][예약어] class 클래스명{        ([]는 생략 가능)
    [접근제한자][예약어]자료형 변수명;       (필드, 메소드, 생성자가 {} 안에 들어옴)
    [접근제한자][예약어]자료형 변수명; 
    [접근제한자] 생성자명(){}
    [접근제한자] 반환형 메소드명(매개변수){
        기능 정의
        }
    };                  

```
- public : 대표적으로 사용되고 Java에서는 무조건 public 사용       ex. public class 클래스명
- default : class 밑에 내부 class만드는 아주 예외적인 상황에서만 사용 / 생략해서 사용됨     ex. class 클래스명

### 소스파일
1. package문
2. import문
3. class 선언부

#### package문
- 폴더와 비슷한 개념 서로 관련된 클래스 혹은 인터페이스의 묶음으로 관리
- 패키지는 서브 패키지를 가질 수 있고 "."으로 구분 ex. Scanner 클래스의 full name은 패키지명이 포함된 java.util.Scanner 
    - 소스파일 첫 번째 문장에 단 한번 선언하며 하나의 소스파일에 둘 이상의 클래스가 포함된 경우, 모두 같은 패키지에 속함
    - 모든 클래스는 하나의 패키지에 속하며, 패키지가 선언되지 않은 클래스는 자동으로 이름없는 패키지(default)에 속함
    - ex. package java.util;

#### import문
- 사용할 클래스가 속한 package를 지정하는데 사용
- import문을 사용하면 클래스를 사용할 때 패키지명 생략 가능
    - com.kh.example.chap02_class.defaultClass.controller.DefaultClassTest가 원래 fullname
- 이름이 같은 클래스가 속한 두 패키지를 import 할 때는 클래스 앞에 패키지 명을 붙여 구분해 주어야 함
- 사용할 package가 어느 위치에 있는지 찾을 용도로 사용되기 때문에 같은 package에 있는 경우 import가 필요 없다
- java.lang 패키지의 클래스는 import를 하지 않고도 사용 가능
    - java.lang 패키지 내의 클래스 : String, Object, System, Math..
- 패키지문과 클래스 선언의 사이에 선언하며 컴파일 시에 처리되므로 프로그램 성능에 영향을 주지 않음

## 필드
- 전역변수, 멤버 변수, 멤버 필드 동의어
```
[접근제한자][예약어]class 클래스명{
	[접근제한자][예약어] 자료형 변수명 [=초기값];
}
```

- 매개변수 : 외부든 내부든 다른 곳에서 값을 받아오는 역할을 함

### 필드 접근제한자 
- public(+) : 전체/ 나 자신, 같은 패키지 내, 외부패키지의 내 후손 가능
- protected(#): 나 자신, 같은 패키지, 다른 패키지에서 사용가능하나 해당 패키지의 클래스가 내 후손일 때 사용 가능
- default(~) : 나 자신,같은 패키지 안까지 가능
- private(-) : 나 자신만(해당 클래스 내부) 사용 가능

### 필드 예약어
- final 
	- 상수 선언 
	- static이랑 같이 사용해서 어디서든지 같이 사용할 수 있도록 씀
	- 공유의 목적을 가지고 있기 때문에 public을 사용함
- static  
	- 같은 타입의 여러 객체가 `공유`할 목적의 필드에 사용
	- static이 붙으면 프로그램 시작시에 정적 메모리 영역에 자동 할당되는 멤버에 적용
	- 클래스 이름만 있으면 객체생성 안해도 사용이 됨

### 필드 - 초기화 블럭
- 인스턴스 변수 : 인스턴스(객체)를 만들어야만 메모리에 올라감
- static 변수, 클래스 변수 : static에 올라가는 변수
- 인스턴스 블럭({}) : 객체 생성시 마다 초기화
    - 변수를 직접 초기화 시키거나 그 안에서 연산이 일어날 때
- static(클래스) 블럭(static{}) : 앞에 static 붙임/ 프로그램 시작 시 한 번만 초기화

### 필드 - 초기화 순서
> 클래스 변수 : jvm 기본값 -> 명시적 초기값 -> 클래스 초기화 블록 초기값
	- 프로그램 시작할 때 메모리의 static 영역에 올라가는 것

> 인스턴스 변수 : jvm 기본값 -> 명시적 초기값 -> 인스턴스 초기화 블록 초기값 -> 생성자를 통한 초기값

- JVM 기본값 : 자료형의 기본값
- 명시적 초기값 : 값을 명시하는 것  ex. private String name = "박신우";
- 인스턴스 초기화 블록 초기값 : 공통적인 연산이 들어가야 하는 경우
